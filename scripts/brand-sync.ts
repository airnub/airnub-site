import { access, cp, mkdir, rm, writeFile } from "node:fs/promises";
import { constants } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

import {
  type BrandConfig,
  airnubNavigation,
  resolveBrandConfig,
  speckitNavigation,
} from "@airnub/brand";
import { speckitBrand } from "../apps/speckit/brand.config";

const brand = resolveBrandConfig();

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(__dirname, "..");

const canonicalBrandAssetsDir = path.join(repoRoot, "packages", "brand", "public", "brand");
const localBrandSourceDir = path.join(repoRoot, ".brand", "public", "brand");
const runtimeDir = path.join(repoRoot, "packages", "brand", "runtime");
const runtimeConfigPath = path.join(runtimeDir, "brand.config.json");
const runtimeTokensPath = path.join(runtimeDir, "tokens.css");
const runtimeSpeckitTokensPath = path.join(runtimeDir, "tokens-speckit.css");
const runtimeNavigationPath = path.join(runtimeDir, "navigation.json");
const apps = ["airnub", "speckit"];

async function pathExists(targetPath: string): Promise<boolean> {
  try {
    await access(targetPath, constants.F_OK);
    return true;
  } catch {
    return false;
  }
}

async function syncDir(source: string, destination: string) {
  await rm(destination, { recursive: true, force: true });
  await mkdir(path.dirname(destination), { recursive: true });
  await cp(source, destination, { recursive: true });
}

function createCssTokens(brandConfig: BrandConfig): string {
  const lines: string[] = [];
  lines.push("/* Generated by scripts/brand-sync.ts â€“ do not edit manually. */");
  lines.push(":root {");
  lines.push(`  --brand-color-primary: ${brandConfig.colors.primary};`);
  lines.push(`  --brand-color-secondary: ${brandConfig.colors.secondary};`);
  lines.push(`  --brand-color-accent: ${brandConfig.colors.accent};`);
  lines.push(`  --brand-color-background: ${brandConfig.colors.background};`);
  lines.push(`  --brand-color-foreground: ${brandConfig.colors.foreground};`);

  if (brandConfig.logos.light) {
    lines.push(`  --brand-logo-light: url("${brandConfig.logos.light}");`);
  }
  if (brandConfig.logos.dark) {
    lines.push(`  --brand-logo-dark: url("${brandConfig.logos.dark}");`);
  }
  if (brandConfig.logos.mark) {
    lines.push(`  --brand-logo-mark: url("${brandConfig.logos.mark}");`);
  }
  if (brandConfig.favicon) {
    lines.push(`  --brand-favicon: url("${brandConfig.favicon}");`);
  }
  if (brandConfig.og) {
    lines.push(`  --brand-og-image: url("${brandConfig.og}");`);
  }

  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

async function main() {
  if (await pathExists(localBrandSourceDir)) {
    await syncDir(localBrandSourceDir, canonicalBrandAssetsDir);
    console.log(`Copied brand assets from ${localBrandSourceDir} to ${canonicalBrandAssetsDir}`);
  } else {
    console.warn(`No local brand overrides found at ${localBrandSourceDir}; using existing package assets.`);
  }

  for (const app of apps) {
    const appBrandDir = path.join(repoRoot, "apps", app, "public", "brand");
    await syncDir(canonicalBrandAssetsDir, appBrandDir);
    console.log(`Synced brand assets to ${appBrandDir}`);
  }

  await mkdir(runtimeDir, { recursive: true });
  await writeFile(runtimeConfigPath, `${JSON.stringify(brand, null, 2)}\n`, "utf8");
  await writeFile(runtimeTokensPath, createCssTokens(brand), "utf8");
  await writeFile(runtimeSpeckitTokensPath, createCssTokens(speckitBrand), "utf8");
  console.log(`Wrote runtime brand config to ${runtimeConfigPath}`);
  console.log(`Wrote runtime CSS tokens to ${runtimeTokensPath}`);
  console.log(`Wrote Speckit runtime CSS tokens to ${runtimeSpeckitTokensPath}`);
  const runtimeNavigation = {
    airnub: airnubNavigation,
    speckit: speckitNavigation,
  };
  await writeFile(runtimeNavigationPath, `${JSON.stringify(runtimeNavigation, null, 2)}\n`, "utf8");
  console.log(`Wrote runtime navigation to ${runtimeNavigationPath}`);
}

main().catch((error) => {
  console.error("Brand sync failed:\n", error);
  process.exit(1);
});
